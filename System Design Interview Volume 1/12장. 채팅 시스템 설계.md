## 문제 이해 및 설계 범위 확정
- 요구사항 분석
	- 플랫폼 지원 여부
	- 트래픽 규모
	- 사용자 수
	- 도메인 주요 정보
	- 종단 간 암호화 여부
	- 등...
## 개략적 설계안 제시 및 동의 구하기
- 클라이언트끼리 직접 소통하는 방식이 아님
	- 클라이언트로부터 메시지 수신
	- 메시지 수신자 결정 및 전달
	- 수신자 상태에 따른 보관 여부 결정
- 어떤 프로토콜을 활용하는 것이 적합한가?
	- 메시지 전송에 사용하는 HTTP 프로토콜
		- `keep-alive` 헤더를 사용해 연결 유지
	- 메시지 수신 시나리오가 복잡함
		- 서버에서 클라이언트로 임의 시점에 메시지 전달이 어려움
		- Polling, Long polling, WebSocket 등...
### 폴링
![](https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b3T7Z5GonDo__72j2OUDmQ.png)
- 주기적으로 서버에게 새 메시지 존재 여부를 확인
- 폴링을 자주 할수록 비용 상승
- 응답이 필요 없을 경우 서버 자원의 불필요한 낭비
### 롱 폴링
![](https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cDNlAy0YrlcxaMVvnhLUCg.png)
- 폴링의 단점 개선
- 클라이언트는 새 메시지가 반환되거나 타임아웃 될 때까지 연결 유지
- 새 메시지를 받으면 기존 연결 종료 → 새로운 요청 전달
	- 무상태 로드 밸런싱 서버의 경우 롱 폴링 연결이 아닌 서버와 연결될 가능성
	- 서버 입장에서 클라이언트의 수신 종료 여부 확인이 어려움
	- 비효율적
### 웹소캣
![](https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fd58bb11f-3727-4ed2-bcbd-dbffe55069c7_1076x1086.png)
- 서버가 클라이언트에 비동기 메시지를 보낼 때 가장 널리 사용하는 기술
- HTTP 연결 이후 handshake 절차를 거쳐 웹 소캣 연결로 업그레이드
- 항구적이고 양방향임
- HTTP/HTTPS 포트 그대로 사용
- 서버의 효율적인 연결 관리 필요
### 개략적 설계안
#### 무상태 서비스
- 전통적인 요청/응답 서비스
- 로드밸런서 뒤에 위치
- 서비스 탐색 서비스
	- 클라이언트가 접속할 채팅 서버의 DNS 호스트명을 클라이언트에 전달
#### 상태 유지 서비스
- 채팅 서비스는 항상 상태가 유지되어야 함
	- 각 클라이언트와 채팅 서버는 독립적인 네트워크 연결 유지 필요
- 서비스 탐색 서비스 활용 특정 채팅 서버에 부하 가중 X
#### 제3자 서비스 연동
- 푸시 알림
- 앱 실행 여부를 벗어나 [[10장. 알림 시스템 설계|알림 전송 필요]]
#### 규모 확장성
- 단일 서버로도 처리 가능하지만 SPO 고려 필요
- 채팅 서버는 클라이언트 간 메시지 중계 역할
- 접속 상태 서버를 통해 접속 여부 관리
- API 서버로 나머지 기능 처리
- 알림 서버는 푸시 알림 전송
- key-value 저장소에 채팅 히스토리 보관
#### 저장소
- 데이터의 유형과 읽기/쓰기 연산 패턴 고려 저장소 선택 필요
- 사용자 프로파일, 설정, 친구 목록등... 일반적인 데이터
	- 안정성 보장을 위한 관계형 데이터베이스 활용
- 채팅 시스템 고유 데이터
	- 특징
		- 채팅 데이터는 양이 방대함
		- 최근 주고받은 메시지 외의 메시지는 자주 접근하지 않음
		- 1:1 채팅의 경우 읽기 쓰기 비율이 1:1임
	- NoSQL → key-value 저장소 추천
		- 수평적 규모 확장의 용이성
		- 데이터 접근 시간이 낮음
		- long-tail 처리에 용이함
		- 대부분의 시스템에서 사용
### 데이터 모델
#### 메시지 ID
- ID는 고유해야함
- 정렬 가능하고 시간 순서와 일치해야함
- [[Announcing Snowflake - X|Snowflake]]와 같은 [[7장. 분산 시스템을 위한 유일 ID 생성기 설계|유일 ID 사용 가능]]
- 지역적 순서 번호 생성기 이용
	- 같은 그룹 내에서만 유일성 보장하기
## 상세 설계
### 서비스 탐색
- 클라이언트에게 가장 적합한 채팅 서버를 추천하는 역할
	- 클라이언트 위치, 서버 용량등을 기준으로 → 오픈소스로 아파치 주키퍼가 있음
- 동작 과정
	1. 사용자가 시스템 로그인 시도
	2. 로드 밸런싱을 통한 API 요청 처리
	3. 사용자 인증 이후 서비스 탐색 기능을 활용해 최적의 채팅 서버 선택
	4. 웹 소켓 연결
### 메시지 흐름
#### 1:1 채팅 메시지 흐름 정리
1. 사용자 A가 채팅 서버 1로 메시지 전송
2. 채팅 서버 1은 ID 생성기 활용 메시지 ID 결정
3. 채팅 서버 1이 해당 메시지를 동기 큐로 전송
4. key-value 저장소에 보관
5. 사용자 B 접속 여부에 따라
	- 접속 중인 경우 채팅 서버 2로 전송
	- 접속 중이 아니면 푸시 알림 서버로 전송
6. 채팅 서버 2는 메시지를 사용해 사용자 B에게 전송(웹소켓 활용)
#### 여러 단말 사이의 메시지 동기화
- 각 단말은 `cur_max_message_id`라는 변수를 유지해 가장 최신 메시지 ID를 추적
- 새 메시지란?
	- 수신자 ID가 현재 로그인한 사용자 ID와 동일
	- key-value 저장소에 보관된 메시지
	- ID가 `cur_max_message_id`보다 큼
#### 소규모 그룹 채팅에서의 메시지 흐름
- 각 사용자 별 메시지 동기화 큐를 사용해 소규모 그룹 채팅 구현
	- 새로운 메시지 조회를 위한 자기 큐 확인
	- 그룹이 크지 않은 경우에 적합
### 접속 상태 표시
#### 사용자 로그인
- 클라이언트와 실시간 서비스 사이에 웹 소켓 연결이 맺어진 후 상태 값을 key-value 저장소에 저장
- 절차가 완료된 이후 해당 사용자는 접속 중으로 표시
#### 로그아웃
- 로그아웃 시 key-value 저장소에 상태 값이 오프라인으로 변경
#### 접속 장애
- `heartbeat` 검사를 활용해 접속 장애 대응
- 주기적으로 heartbeat event를 서버에 전송해 접속 장애가 발생했을 때 오프라인으로 처리되지 않도록 함
#### 상태 정보의 전송
- pub-sub 모델을 사용 구현
- 친구 관계마다 채널을 하나씩 만들어 상태를 전달
- 그룹 크기가 작은 경우에 적합
## 마무리
- 추가로 논의하면 좋을 것
	- 채팅 및 미디어 지원
	- 종단 간 암호화
	- 캐시
	- 로딩 속도 개선
	- 오류 처리
		- 채팅 서버에 오류가 발생했을 때
		- 메시지 재전송
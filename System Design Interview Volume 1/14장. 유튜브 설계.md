## 문제 이해 및 설계 범위 확정
- 설계 분석
	- 비디오 업로드 및 시청
	- 플랫폼 지원 여부
	- DAU
	- 다국어 지원 여부
	- 암호화 지원 여부
	- 클라우드 서비스 사용 여부
## 개략적 설계안 제시 및 동의 구하기

> CDN과 BLOB를 직접 만드는 것은 매우 복잡하고 비용이 많이 듬

- 컴포넌트 구성
	- 단말: 컴퓨터, 폰, TV를 통해 유튜브를 시청할 수 있음
	- CDN: 비디오 저장 위치
	- API 서버: 스트리밍을 제외한 모든 API 요청 처리
### 비디오 업로드 절차
![](https://velog.velcdn.com/images/ony/post/d0ba10f7-66c1-4e65-b0c4-532890239e30/image.png)
	- 사용자: 유튜브를 시청하는 이용자
	- 로드밸런서: API 서버 요청 분산
	- API 서버: 비디오 스트리밍 제외 다른 요청 처리
	- 메타데이터 DB: 비디오 메타데이터 보관
	- 메타데이터 캐시: 성능 향상을 위한 캐싱
	- 원본 저장소: 원본 비디오 저장용 BLOB 시스템
	- 트랜스코딩 서버: 비디오 인코딩 서버
	- 트랜스코딩 비디오 저장소: 인코딩이 완료된 비디오 저장소
	- CDN: 비디오 캐싱
	- 트랜스코딩 완료 큐: 트랜스코딩 완료 이벤트 보관 메시지 큐
	- 트랜스코딩 완료 핸들러: 이벤트 핸들링 핸들러

- 비디오 업로드는 아래 프로세스를 병렬로 수행
	- [[#비디오 업로드]]
	- [[#메타데이터 갱신|비디오 메타데이터 갱신]]
#### 비디오 업로드
1. 비디오 원본 저장소 업로드
2. 트랜스코딩 서버로 트랜스코딩 진행
3. 트랜스코딩 완료 이벤트를 트랜스코딩 완료 큐에 적재
	1. 트랜스코딩이 끝난 비디오 CDN 적재
	2. 완료 핸들러가 이벤트 핸들링 시작
	3. 메타데이터 DB와 캐시 갱신 
4. API 서버에 완료 전달
#### 메타데이터 갱신
- 원본 저장소에 파일이 업로드 되는 동안 동시에 비디오 메타데이터 갱신 진행
	- 파일 이름, 크기, 포맷 등의 정보
### 비디오 스트리밍 절차
- 스트리밍: 지속적으로 비디오 스트림을 전송 받아 영상을 재생
- 스트리밍 프로토콜
	- MPEG-DASH
	- Apple HLS
	- Microsoft Smooth Streaming
	- Adobe HTTP Dynamic Streaming
- 프로토콜마다 지원하는 인코딩이 다르고 플레이어도 다름
- 비디오는 CDN에서 바로 스트리밍 됨
## 상세 설계
### 비디오 트랜스코딩
- 다른 단말과 호환되는 비트레이트와 포맷으로 변환하는 과정
	- 가공되지 않은 원본 비디오는 저장 공간을 많이 차지함
	- 대부분의 단말과 브라우저는 특정 종류의 비디오 포맷만 지원함
	- 네트워크 대역폭에 따라 화질을 조정해 전송해야 함
	- 네트워크 상황이 수시로 바뀌는 모바일 환경의 특성상 비디오 화질 자동 변경 필요
- 인코딩 포맷
	- 컨테이너: 비디오 파일, 오디오, 메타데이터를 담는 바구니
	- 코덱: 비디오 화질은 보존하면서 파일 크기를 줄이는 목적으로 고안된 압축 및 해제 알고리즘
### 유향 비순환 그래프(DAG) 모델
- 각기 다른 비디오 프로세싱 파이프라인을 지원하면서 처리 과정의 병렬성을 높여야 함 → 추상화 도입 필요
	- 페이스북의 스트리밍 비디오 엔진은 DAG를 도입해 병렬 처리를 가능하게 함
![](https://velog.velcdn.com/images/ony/post/49a0133c-5a61-4d74-bb18-0b2b9c152209/image.png)
	- 검사: 비디오 손상 여부 및 품질 검사
	- 비디오 인코딩: 다양한 해상도, 코덱, 비트레이트 조합으로 인코딩하는 작업
	- 섬네일: 사용자 업로드 이미지나 비디오 자동 추출 이미지로 섬네일 생성
	- 워터마크: 식별정보 표시
### 비디오 트랜스코딩 아키텍처
![](https://velog.velcdn.com/images/ony/post/1a38bbb9-f73e-4817-84a1-8e1faaa2b020/image.png)
#### 전처리기
- 비디오 분할
	- 비디오 스트림을 GOP(특정 순서로 배열된 프레임 그룹) 단위로 분리
	- 하나의 GOP는 독립적으로 재생 가능함
- DAG 생성
	- 설정에 따라 DAG 생성
- 데이터 캐시
	- GOP와 메타데이터를 임시 저장소에 보관 → 인코딩 실패시 임시 데이터 활용 재개
#### DAG 스케줄러
- DAG 그래프를 단계로 분할한 후 각각을 작업 큐에 집어넣음
#### 자원 관리자
- 자원 배분을 효과적으로 수행하는 역할 담당
- 구성
	- 작업 큐: 실행 할 작업 보관 우선순위 큐
	- 작업 서버 큐: 작업 서버의 가용 상태 정보 보관 우선순위 큐
	- 실행 큐: 실행 중인 작업 및 작업 서버 정보 보관 큐 
	- 작업 스케줄러: 최적의 작업 스케줄링 및 지시
- 동작
	1. 작업 큐에서 가장 우선순위가 높은 작업 poll
	2. 해당 작업에 적합한 작업 서버 선택 및 지시
	3. 작업 및 서버 할당 정보 실행 큐 적재
	4. 작업 완료시 해당 작업을 실행 큐에서 제거
#### 작업 서버
- DAG에 정의된 작업 수행
#### 임시 저장소
- 구현에는 여러 저장소 시스템 활용 가능
#### 인코딩된 비디오
- 최종 결과물
### 시스템 최적화
#### 속도 최적화: 비디오 병렬 업로드
- GOP로 분할 후 병렬 업로드 진행
#### 속도 최적화: 업로드 센터를 사용자 근거리에 지정
- 업로드 센터를 여러 곳에 두어 각 위치에 가까운 업로드 센터로 데이터 업로드
#### 속도 최적화: 모든 절차를 병렬화
- 느슨하게 결합된 시스템을 만들어 병렬성 향상
- 메시지큐 도입을 통한 이벤트 기반 병렬성 향상
#### 안전성 최적화: Pre-signed URL
- 허가 받은 사용자만 올바른 장소에 비디오 업로드 가능
#### 안전성 최적화: 비디오 보호
- DRM 도입
- AES 암호화
- 워터마크
#### 비용 최적화
- 유튜브의 비디오 스트리밍은 long-tail 분포를 따름
	- 인기 있는 비디오만 자주 재생됨
- 인기 있는 비디오만 CDN으로 나머지는 비디오 서버로 재생하기
- 인기 기반 인코딩 여부 결정
- 지역 기반 비디오 관리
- CDN 직접 구현(?)
### 오류 처리
- 회복 가능 오류와 회복 불가능 오류 구분 후 오류 처리
	- 회복 가능 여부: 재시도로 해결 가능한 오류 vs 재시도로도 처리하지 못하는 오류
## 마무리
- 추가로 논의하면 좋을 것
	- API 계층의 규모 확장성 확보 방안
	- 데이터베이스 계층의 규모 확장성 확보 방안
	- 라이브 스트리밍
	- 비디오 삭제
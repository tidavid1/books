- 처리율 제한 창치(rate limiter): 클라이언트 또는 서비스가 보내는 **트래픽의 처리율(rate)을 제어하기 위한 장치**
- API 요청 횟수가 **임계치(threshold)를 넘어서면** 추가로 도달한 모든 호출은 처리가 **중단(block)**됨
- 처리율 제한 장치를 두면 좋은 점
	- DoS(Denial of Service) 공격에 의한 **자원 고갈 방지**
	- 추가 요청에 대한 처리 제한을 통한 **비용 절감**
	- 잘못된 이용 패턴이나 봇에서 유발된 트래픽을 걸러내 **서버 과부하 방지**

## 문제 이해 및 설계 범위 확정
### 설계 요구사항
- 설정된 처리율을 초과하는 요청은 정확하게 제한
- HTTP 응답 시간에 부정적인 영향을 주어서는 안됨 → 낮은 응답시간
- 적은 메모리 사용
- 하나의 처리율 제한 장치를 여러 서버나 프로세스에서 공유할 수 있어야 함 → 분산형 처리율 제한
- 예외 처리를 통한 요청 제한 사실 전달
- 제한 장치에 장애가 생기더라도 시스템에 영향을 주어서는 안됨 → 높은 결함 감내성

## 개략적 설계안 제시 및 동의 구하기
### 처리율 제한 장치의 위치는?
- 가능한 위치는?
	- 클라이언트
		- 클라이언트의 요청은 쉽게 위변조가 가능해 처리율 제한을 안정적으로 걸 수 없음
	- 서버
		- 요청에 대한 처리율 제한 기능 구현
	- 미들웨어
		- 미들 웨어에 의해 처리율이 제한됨 → 서버는 처리율 제한 사실을 모름
- [클라우드 마이크로서비스](https://www.ibm.com/topics/microservices)의 경우 처리율 제한 장치를 **API 게이트웨이**에 구현
	- API 게이트웨이: 처리율 제한, SSL 종단, 사용자 인증, IP Whitelist 관리 등을 지원하는 **완전 위탁관리형 서비스**
	- 클라우드 업체가 유지보수를 담당함
- 설계 과정에서 고려할만한 포인트들
	- **현재 기술 스택**이 서버 측 구현을 지원하기에 충분한 효율이 있는지 판단하기
	- (서버 구현 시)적절한 **[[#처리율 제한 알고리즘]]** 선정
	- **마이크로서비스에 기반한 설계**이고 **API 게이트웨이가 존재**한다면 처리율 제한 기능 또한 게이트웨이에 포함시켜야 함
	- 직접 구현하는 시간 vs 상용 API 게이트웨이 사용

### 처리율 제한 알고리즘
- 토큰 버킷 알고리즘 ^90439b
	- 간단하고 이해도가 높아 보편적으로 사용하는 알고리즘
	- **지정된 용량**을 갖는 컨테이너에 사전 설정된 양의 **토큰**이 주기적으로 채워짐
	- 버킷이 가득 차면 추가로 공급된 토큰은 버려짐
	- 요청을 처리할 때마다 버킷에 토큰이 충분히 있는지 검사하고 사용
		- 토큰이 충분히 존재하면 토큰을 사용해 요청 전달
		- 토큰이 없으면 요청 버리기
	```mermaid
	flowchart LR
		A[Request] -->|Send Request| B(Token Bucket)
		B --> C{Is token enough?}
		C -->|Yes| D[Send Request to Server]
		C -->|No| E[Drop Request]
	```
	- 2개의 인자 필요
		- **버킷 크기**: 버킷에 담을 수 있는 토큰의 최대 갯수
		- **토큰 공급률**: 초당 몇 개의 토큰이 버킷에 공급되는가
	- 버킷 갯수는 공급 제한 규칙에 따라 달라짐
		- 통상적으로 API 엔드포인트마다 별도의 버킷을 둠
		- IP 주소별로 처리율 제한을 적용하고자 한다면 IP 주소마다 버킷 필요
		- 시스템 처리율을 제한하고자 한다면 모든 요청이 하나의 버킷을 공유해야 함
	- **장점:**
		- 구현이 쉬움
		- 메모리 사용 측면에서 효율적임
		- 짧은 시간에 집중되는 트래픽 처리 가능
	- **단점:**
		- **버킷 크기**, **토큰 공급률** 인자를 적절하게 튜닝하는 것이 중요함

- 누출 버킷 알고리즘
	- [[#^90439b|토큰 버킷 알고리즘]]과 비슷하지만 **요청 처리율이 고정**되어 있음
	- FIFO(First-In-First-Out) 큐로 구현
	- 요청을 처리할 때마다 큐가 가득 차 있는지 확인 후 요청 추가
		- 큐가 가득 차 있는 경우 새 요청은 버림
		- 지정된 시간마다 큐에서 요청을 꺼내 처리
	```mermaid
	flowchart LR
		A[Request] -->|Send Request| B(Token Bucket)
		B --> C{Is Queue full?}
		C -->|Yes| D[Drop Request]
		C -->|No| E[Add Request in Queue]
		E -->|Scheduling| F(Handle Request)
	```
	- 2개의 인자 필요
		- **버킷 크기**: 큐 사이즈와 동일한 값
		- **처리율**: 지정된 시간당 몇 개의 항목을 처리할지 지정하는 값(일반적으로 초 단위)
	- **장점:**
		- 큐 사이즈 제한을 통한 메모리 사용의 효율성
		- 고정된 처리율을 보장해 안정적 출력이 가능
	- **단점:**
		- 단시간에 많은 트래픽이 몰리는 경우 최신 요청이 버려지는 문제 발생
		- **버킷 크기**, **처리율** 인자를 적절하게 튜닝하는 것이 중요함

- 고정 윈도 카운터 알고리즘 ^fcff75
	- 타임라인을 고정된 간격의 윈도로 나누고 각 윈도마다 카운터를 활용
		- 설정된 임계치를 넘는 요청이 오면 새로운 요청들은 버려짐
	- 윈도의 경계 부근에 순간적으로 많은 트래픽이 집중될 경우 할당량보다 많은 요청이 처리될 수 있음
	- **장점:**
		- 메모리 효율의 이점
		- 이해하기 쉬움
		- 윈도가 닫히는 시점에서 카운터를 초기화해 특정 트래픽 패턴 처리에 적합
	- **단점:**
		- 윈도 경계 부근에 트래픽이 몰리는 경우 기대한 한도보다 더 많은 양의 요청 처리 가능성

- 이동 윈도 로깅 알고리즘 ^21e231
	- [[#^fcff75|고정 윈도 카운터 알고리즘]]의 경계 부근 트래픽 집중 문제를 해결한 알고리즘
	- 요청의 타임스탬프를 추적해 로깅하는 방식
		- 새로운 요청이 오면 만료된 타임스탬프는 제거
		- 새 요청의 타임스탬프 로깅
		- 로그의 크기가 허용치보다 같거나 작으면 요청 전달 크면 처리 거부
	- **장점:**
		- 메커니즘의 정교함에 의해 처리율 한도를 항상 넘지 않음
	- **단점:**
		- 메모리 사용량 과다 → 거부된 요청의 타임스탬프도 보관하기 때문

- 이동 윈도 카운터 알고리즘
	- [[#^fcff75|고정 윈도 카운터 알고리즘]] + [[#^21e231|이동 윈도 로깅 알고리즘]]
	- **장점:**
		- 이전 시간대의 평균 처리율에 기반해 현재 윈도 상태를 계산해 트래픽 대응력이 좋음
		- 메모리 효율 이점
	- **단점:**
		- 추정치 계산 기준으로 균등 분포를 가정해 다소 느슨함 

### 개략적인 아키텍처
- 얼마나 많은 요청이 접수되었는지를 추적할 수 있는 **카운터**를 **추적 대상별**로 두고, 이 카운터의 **값이 어떤 한도를 넘어서면** **이후 요청은 거부**하는 것
- 그렇다면 카운터를 보관하는 위치는?
	- 속도상의 이점때문에 메모리상에서 동작하는 캐시가 바람직함(Redis)
- 동작 원리
	- 클라이언트가 처리율 제한 미들웨어에게 요청
	- 레디스 지정 버킷에서 카운터를 가져와 한도 검사
		- 한도 도달시 요청 거부
		- 한도 미도달시 요청 API 서버 전달 및 미들웨어 카운터 증가

## 상세 설계
- 처리율 제한 규칙 관리 및 제한 요청 처리 방법
### 처리율 제한 규칙
- 보통 **설정 파일** 형태로 디스크에 저장
### 처리율 한도 초과 트래픽의 처리
- HTTP 429 응답을 클라이언트에 전송
- (경우에 따라서) 한도 제한 메시지를 큐에 보관 후 나중에 처리
- HTTP 응답 헤더에 처리율 제한이 걸리기까지 남은 요청 수와 같은 정보를 담아서 보낼 수 있음
	- `X-Ratelimit-Remaining`: 윈도 내 남은 처리 가능 요청 수
	- `X-Ratelimit-Limit`: 매 윈도마다 클라이언트가 전송할 수 있는 요청의 수
	- `X-Ratelimit-Retry-After`: 한도 제한에 걸리지 않으려면 몇 초 뒤에 요청을 다시 보내야 하는지 알림
### 상세 설계 결과
- 처리율 제한 규칙은 디스크에 보관
	- 작업 프로세스는 수시로 규칙을 디스크에서 읽어 캐시에 저장
- 클라이언트가 요청을 서버에 보내면 요청은 처리율 제한 미들웨어에 도달
- 제한 규칙을 캐시에서 마지막 요청의 타임스탬프를 레디스 캐시에서 가져옴 → 판단
	- 처리율 제한에 걸리지 않은 경우 API 서버로 보냄
	- 처리율 제한에 걸리면 HTTP 429 응답 전송
		- 요청을 버릴수도, 메시지 큐에 보관할 수도 있음

### 분산 환경에서의 처리율 제한 장치의 구현
- 여러 대의 서버와 병렬 스레드를 지원하도록 시스템을 확장하려면 두 가지 문제를 해결해야함
	- 경쟁 조건, 동기화
- 경쟁 조건
	- 카운터에 동시에 접근해서 값을 증가시키는 경우
	- **lock**을 활용한 해결 방안이 일반적
		- Lua Script나 Redis의 Sorted Set을 사용해 해결 가능
- 동기화 이슈
	- 처리율 제한 장치 서버가 여러대 있는 경우 동기화가 필요
	- 고정 세션(Sticky Session)을 활용해 같은 클라이언트 요청은 항상 같은 처리율 제한 장치로 보내도록 하는 방법
		- 유연하지 않고 확장이 어려움
	- Redis와 같은 중앙 집중형 데이터 저장소 사용
- 성능 최적화
	- 여러 데이터 센터를 지원 과정에서 발생하는 지연시간 증가 해결을 위해 에지 서버 활용
	- 최종 일관성 모델을 사용해 데이터 동기화
- 모니터링
	- 처리율 알고리즘과 처리율 제한 규칙의 효율성 판단을 위해 데이터를 모아 모니터링 필요

## 마무리
- 더 고려할만한 점들
	- hard or soft 처리율 제한
		- 임계치를 절대 넘을 수 없는 요청(hard) vs 임계치를 잠시 동안 넘을 수 있는 요청(soft)
	- 다양한 네트워크 계층에서 처리율 제한
		- L7 처리율 제한 외에 L3 (IP) 계층 처리율 제한도 가능함
	- 처리율 제한을 회피하는 방법과 클라이언트 설계 고려
		- 클라이언트 캐시를 활용한 API 호출 감소
		- 임계치에 기반한 설계
		- 클라이언트 예외, 에러 핸들링 도입
		- 충분한 백오프 시간과 함께하는 재시도 로직
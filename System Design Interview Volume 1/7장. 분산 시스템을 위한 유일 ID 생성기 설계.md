## 문제 이해 및 설계 범위 확정
- 설계를 위해 고려해야 할 상황
	- ID의 특성
	- ID 생성 로직
	- ID 구조
	- ID를 활용하는 시스템 규모
## 개략적 설계안 제시 및 동의 구하기
### 다중 마스터 복제
- DB의 `auto_increment` 기능을 활용해 유일 ID 구현
	- 다음 ID의 값을 구할 때 1만큼 증가시키는 것이 아닌 `k`만큼 증가 → `k`: 현재 사용중인 데이터베이스 서버 수
- 규모 확장성 문제를 어느정도 해결할 수 있음
- 단점
	- 여러 데이터 센터에 걸쳐 규모를 늘리기 어려움
	- ID의 유일성은 보장되나 **값이 시간 흐름에 맞춰 커지도록 보장할 수 없음**
	- **서버 추가, 삭제시** 동작 구현이 어려움
### UUID
- **UUID**: 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트짜리 수
- 충돌 가능성이 지극히 낮음
- `550e8400-e29b-41d4-a716-446655440000` 형식
	- 8-4-4-4-12 포맷을 따름
- 서버 간 조율 없이 독립적으로 생성 가능
- 장점
	- 생성이 단순하고 서버 사이의 조율이 필요 없음 → 동기화 이슈 X
	- 규모 확장에 용이
- 단점
	- ID 기반 시간순 정렬이 어려움
	- ID에 숫자가 아닌 값이 포함됨
	- ID가 128비트로 긴 편임
### 티켓 서버
- `auto_increment` 기능을 갖춘 티켓 서버를 중앙 집중형으로 하나만 사용
	- [[Ticket Servers; Distributed Unique Primary Keys on the Cheap - Flickr|Flickr]]에서 활용
- 장점
	- 유일성이 보장되는 오직 숫자로만 구성된 ID를 쉽게 만들 수 있음
	- 구현이 쉬움
- 단점
	- 티켓 서버가 **SPOF**가 됨
### 트위터 스노플레이크 접근법
- [[Announcing Snowflake - X|트위터]]가 사용하는 독창적인 ID 생성 기법
- 구조
	![](https://external-preview.redd.it/Y1GT0_vuow-YquuhHz6HbfJPox2nK8cGpDWP6obqRD0.jpg?auto=webp&s=73f29b6b57d243b7f1e84a4b35eddfcf6ca73ad8)
	- Timestamp: 41 Bits
		- 기원 시각(epoch) 이후 몇밀리초가 경과했는지 나타내는 값. → 약 69년 표현 가능
	- Sequence: 12 Bits
		- 동일한 밀리초에 ID가 생성되지 않는 한 일반적으로 0 → 각 밀리초마다 0으로 초기화
	- Instance: 10 Bits
		- 프로세스 전체에 대한 고유한 임의 숫자
		-  책에서는 DC ID 5 Bits, Server Id 5 Bits 할당
## 상세 설계 및 마무리
### Timestamp
- 69년이 지나면 기원 시각을 바꾸거나 ID 체계를 migration 해야함
- ID 생성 서버가 물리적으로 독립된 여러 장비에서 실행되 시계 동기화가 필요할 수 있음
### 스노플레이크 절 분리
- 동시성이 낮고 수명이 긴 어플리케이션의 경우 Sequence의 크기를 줄이고 Timestamp 길이를 늘리는 것이 효과적일 수 있음
### 고가용성
- ID 생성기는 필수 불가결 컴포넌트이므로 아주 높은 가용성을 제공해야 함